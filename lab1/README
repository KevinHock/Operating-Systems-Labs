Design and subtle logic flaws did me in, after 3 hard resets here it is.
It goes through checks all the flags and determines the code flow from there.
I wrote it in libc first and it worked perfectly. Then everything was going great until I tried calling mmap through this format "buffer = mmap(0, fileSize, PROT_READ, MAP_SHARED, g, 0);" and it destroyed me and my entire project. I was unware of the fact that I could just use [1000] until it was all too late; have mercy. 


libc is easier to read so here is the pseudo real program.


int dFlag=0,cFlag=0,hFlag=0,rFlag=0,uFlag=0,stdoutFlag=0,stdinFlag=0;

int length(char* string);

void stdinFlagSetter(char* string){
    if(length(string)==1 && *string==45)
        stdinFlag=1;
}

void stdoutFlagSetter(char* string){
    if(length(string)==1 && *string==45)
        stdoutFlag=1;
}

void letterFlagSetter(char* string){
  int flagLoop=1;
  for(;flagLoop<length(string);flagLoop++)
    switch(*(string+flagLoop)){
        case 'd':
            dFlag=1;
            break;
        case 'c':
            cFlag=1;
            break;
        case 'h':
            hFlag=1;
            break;
        case 'r':
            rFlag=1;
            break;
        case 'u':
            uFlag=1;
        default:
            break;
    }
}

int length(char* string){
    int length=1;
    for(;;){
        if(*(string+length)==0)break;
        length++;
    }
    return length;
}

int main(int argc, char **argv) {
    int flagLoop;
    //Set all letter flags
    if(argc>3)
        for(flagLoop=1;flagLoop<argc-2;flagLoop++)
            letterFlagSetter(*(argv+flagLoop));
    //printf("dFlag=%d\ncFlag=%d\nhFlag=%d\nrFlag=%d\nuFlag=%d\n",dFlag,cFlag,hFlag,rFlag,uFlag);
    
    //Set stdin and stdout flags
    if(argc>2){
        stdinFlagSetter( *(argv+argc-2));
        stdoutFlagSetter(*(argv+argc-1));
    }
    //printf("stdoutFlag=%d\nstdinFlagFlag=%d\n",stdoutFlag,stdinFlag);
    
    //Check stat
    //mmap whole file
    
    
    if(dFlag==1 && uFlag==1){
        puts("ERROR: Cannot have DOS Style newlines and Unix Style newlines.");
        hFlag=1;
        dFlag=uFlag=rFlag=cFlag=0;
    }
    if(hFlag==1)
        printf("Proper use is fileutil [-cdhru] infile|- outfile|-\n-c: Counts the newlines in the file and outputs to stderr.\n-d: Converts the output to use DOS-style newlines.\n-h: Prints a help message.\n-r: Reverses the contents of the file, on a line-by-line basis.\n-u: Converts the output to use Unix-style newlines.\n");
    
/*
//
  char *name = "abc.txt";
  struct stat stbuf;
  struct stat *pointy=&stbuf;
//stat(name, &stbuf);
  statistics(18,name, pointy);
  short fileSize = stbuf.st_size;
  int jamesDean=0;
  if(fileSize==15)
       sys_write(4,1,"Wow\nWow\n",8,jamesDean);
*/
    
    
    char *name = "abc.txt";
    struct stat stbuf;
    stat(name, &stbuf);
    short fileSize = stbuf.st_size;
    
    FILE *targetFile;
    targetFile = fopen(*(argv+argc-2),"r");
    if(!targetFile){
        puts("Failed to open file.");
        return(1);
    }
    
    char* buffer = malloc(fileSize);
    int howMuchRead = fread(buffer, sizeof(char), fileSize, targetFile);
    fclose(targetFile);
    
    int newLineCount=0,offset=0;
    char currChar;
    if(cFlag==1 || rFlag==1)
        for(;;){
            currChar=*(buffer+offset++);
            if(10==(int)currChar)
                newLineCount++;
            if(currChar==EOF)
                break;
        }
    if(cFlag==1)printf("The number of newlines = %d\n",newLineCount);
    
    
    
    
    
    
    FILE *sampleFile;
    sampleFile=fopen("4.txt","w");
    if(!sampleFile){
        puts("Error with 4.txt");
        return(1);
    }
    //-d
    
    offset=0;
    if(dFlag && !rFlag)//prints garbage at the end so I put printf("I just put %x in the file\n",currChar); // hex fiend to make sure and found out it was putting null bytes and -1
        while(1){
            currChar=*(buffer+offset++);
            if((currChar==EOF || currChar == 0 || currChar ==-1))// && f!=0)
                break;
            if(10==(int)currChar)
                fputc(13,sampleFile);
            fputc(currChar,sampleFile);
            printf("I just put %x in the file\n",currChar);
        }
    
    if(uFlag && !rFlag)
        while(1){
            currChar=*(buffer+offset++);
            if((currChar==EOF || currChar == 0 || currChar ==-1))
                break;
            if(13!=(int)currChar)
                fputc(currChar,sampleFile);
            printf("I just put %x in the file\n",currChar);
        }
    
    if(rFlag){
        //Get the offset of each newline
        offset=0;
        int nlaIndex=0;//ghi
        int **newLineArray = malloc(newLineCount * sizeof(int *));
        //*(argv+(newLineCount-1))
        //printf("newLineCount is %d\n",newLineCount);
        
        *(newLineArray+nlaIndex)=0;
        int ttt=1;
        //Get offsets
        for(;;){
            currChar=*(buffer+offset++);
            printf("currChar = %x\n", currChar);
            if(currChar==EOF || currChar == 0 || currChar ==-1)
                break;
            if(10==(int)currChar)
                nlaIndex++;
            else
                *(newLineArray+nlaIndex)=ttt;
            ttt++;
            printf("Count is %d\n",*(newLineArray+nlaIndex));
        }
        ///
        int p;
        for(p=newLineCount-1;p>=0;p--){
            printf("The number to add to buffer is %d \n",(int)(*(newLineArray+p)));
            printf("Offset %d should be %x\n",p,*(buffer+(int)(*(newLineArray+p))));
        }
        ///
        //ghi free what you malloc
        
        //We have the offsets
        int dosFlag=0;
        //Assuming CR won't be in a UNIX text file.
        if(!uFlag && !dFlag){
            for(;;){
                currChar=*(buffer+offset++);
                if(currChar==13)
                    dosFlag=1;
                if(currChar==EOF || currChar == 0 || currChar ==-1 || currChar == 10)
                    break;
            }
        }
        else
            dosFlag=dFlag;
        
        
        
        //dFlag should be 0 without flags from abc.txt
        //printf("dosFlag is %d\nnewLineCount is %d\n",dosFlag,newLineCount);
        //printf("1st offset is %d\n",newLineArray[0]);
        /*
        char bla = *(buffer+newLineArray[newLineCount-1]);
        printf("The first char is %c\n",bla);
        
        //newLineArray[newLineCount-1] to newLineArray[0]
        */
        
        
        
        int writeIt;//ghi fix writeIt
        int cobain=0;
        
        for(writeIt=newLineCount-1;writeIt>=-1;writeIt--){
            //printf("\t Char = %x\n",*(buffer+(int)(*(newLineArray+writeIt))));
            //printf("\t writeIt = %d\n",writeIt);
            if(writeIt!=-1)
                cobain=(int)(*(newLineArray+writeIt))+1;
            else
                cobain=0;
            printf("\t index of '\\n' is = %d\n",cobain);
            
        
            
            offset=0;
            
        
            for(;;){
            currChar=*(buffer+cobain+offset++);
            //
            //printf("writeIt is %d\noffSet is %d\n",writeIt,offset);
            printf("The currChar is %x & cobain = %d\n& offset is %d\n",currChar,cobain,offset);
            //
            if( currChar == 10 || currChar == EOF || currChar == 0 || currChar == -1  ){
                if( dosFlag && writeIt!=(newLineCount-1) ){
                    fputc('\r',sampleFile);
                    fputc('\n',sampleFile);
                }
                if(!dosFlag && writeIt != (newLineCount-1) )
                    fputc('\n',sampleFile);
                break;
            }
            fputc(currChar,sampleFile);
            }
            
        }
        
    }    
    
    fclose(sampleFile);
    return 0;
}

